{
  "NeuralNetwork": {
    "prefix": ["torch"],
    "body": [
      "import torch",
      "import torch.nn as nn",
      "import torch.nn.functional as F",
      "import torch.optim as optim",
      "from collections.abs import Sequence",
      "class ${1:NeuralNetwork}(nn.Module):",
      "    def __init__(self):",
      "        super($1, self).__init__()",
      "        #self.conv = nn.Conv2d(1, 6, 5)",
      "        #self.pool = nn.MaxPool2d(kernal_size=)",
      "        #self.fc = nn.Linear(in_features=, out_feautures=)",
      "        $0",
      "",
      "    def forward(self, x):",
      "        pass",
      "",
      "#training neural network",
      "def train(",
      "    nn: nn.Module,",
      "    trainset: Sequence[tuple[torch.Tensor, torch.Tensor]],",
      "    valset: Sequence[tuple[torch.Tensor, torch.Tensor]],",
      "    epochs: int):",
      "    criterion = nn.MSELoss()",
      "    optimizer = optim.SGD(nn.parameters(), lr=0.1)",
      "    optimizer.zero_grad()",
      "    for epoch in range(epochs):",
      "        for x, y_ref in trainset:",
      "            optimizer.zero_grad()",
      "            y = nn(x)",
      "            loss = criterion(y, y_ref)",
      "            loss.backwar()",
      "            optimizer.step()"
    ]
  },
  "sqlite": {
      "prefix": ["sqlite"],
      "body": [
          "import sqlite3",
          "class SQLiteDB(object):",
          "    def __init__(self, dbpath=\"sqlite3.db\"):",
          "        self.conn = sqlite3.connect(dbfile)",
          "        self.cur = self.conn.cursor()",
          "        #CreateTable self.cur.execute('CREATE TABLE table (id VARCHAR, value TEXT);')",
          "        #AddItem self.cur.execute(f'INSERT INTO table VALUES(\\'{key}\\', \\'{value}\\');')",
          "        #    self.conn.commit()",
          "        #Fetch self.cur.execute(f'SELECT id, value FROM table WHERE id = \\'{key}\\';)",
          "        #  result = self.cur.fetchone() or self.cur.fetchall()?"
      ]
  }
}
